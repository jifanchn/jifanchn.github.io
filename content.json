{"pages":[],"posts":[{"title":"STM32 HAL库CAN注意点","text":"现象 CAN滤波器不正常工作；F4的双路CAN不正常工作。 原因 CAN滤波器设置为32位时，需要向左移动固定位作为滤波，这是STM32底层的规则，HAL库没有屏蔽； STM32F407的双路CAN，CAN1作为CAN0的从机，需要设置更多的内容，用同一个队列，但是滤波器起始不同。 F1: 1234567891011121314151617181920212223242526// set address and mask hereCAN_FilterTypeDef sFilterConfig;HAL_StatusTypeDef HAL_Status;sFilterConfig.FilterBank = 0;sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;// 28:24 -&gt; device_type// 23:16 -&gt; address// 15:0 -&gt; cmdsFilterConfig.FilterIdHigh = (app-&gt;app_io-&gt;address + (app-&gt;device_type &lt;&lt; 8)) &lt;&lt; CAN_TI0R_EXID_Pos;sFilterConfig.FilterIdLow = 0;sFilterConfig.FilterMaskIdHigh = 0x1FFF &lt;&lt; CAN_TI0R_EXID_Pos;sFilterConfig.FilterMaskIdLow = 0;sFilterConfig.FilterFIFOAssignment = CAN_FILTER_FIFO0;sFilterConfig.FilterActivation = ENABLE;sFilterConfig.SlaveStartFilterBank = 0;if (hcan.State == HAL_CAN_STATE_LISTENING) HAL_Status = HAL_CAN_Stop(&amp;hcan);HAL_Status = HAL_CAN_ConfigFilter(&amp;hcan, &amp;sFilterConfig);HAL_Status = HAL_CAN_Start(&amp;hcan);HAL_Status = HAL_CAN_ActivateNotification(&amp;hcan, CAN_IT_RX_FIFO0_MSG_PENDING); 1HAL_CAN_AddTxMessage(&amp;hcan, &amp;TxMessage, data, (uint32_t*)&amp;mailbox); F4: 1234567891011121314151617181920212223242526// receive everythingCAN_FilterTypeDef sFilterConfig;HAL_StatusTypeDef HAL_Status;sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;sFilterConfig.FilterIdHigh = 0;sFilterConfig.FilterIdLow = 0;sFilterConfig.FilterMaskIdHigh = 0;sFilterConfig.FilterMaskIdLow = 0;if (hcan == &amp;hcan1) { sFilterConfig.FilterBank = 0;}else { sFilterConfig.FilterBank = 14;}sFilterConfig.FilterFIFOAssignment = CAN_FILTER_FIFO0;sFilterConfig.SlaveStartFilterBank = 14;sFilterConfig.FilterActivation = ENABLE;if (hcan-&gt;State == HAL_CAN_STATE_LISTENING) HAL_Status = HAL_CAN_Stop(hcan);HAL_Status = HAL_CAN_ConfigFilter(hcan, &amp;sFilterConfig); // https://www.oipapio.com/cn/article-3490173HAL_Status = HAL_CAN_Start(hcan);HAL_Status = HAL_CAN_ActivateNotification(hcan, CAN_IT_RX_FIFO0_MSG_PENDING); 1HAL_CAN_AddTxMessage(&amp;hcan, &amp;TxMessage, data, (uint32_t*)&amp;mailbox); 其它注意点 需要在STM32CUBEMX中打开的中断只有： 1234F1:CAN RX1 interruptsF4:CAN RX0 interrupts 需要打开： 12Automatic Bus-off ManagementAutomatic Wake-Up mode 以防止CAN死掉； 波特率计算方法是： 123(Time Quanta in Bit Segment 1) + (Time Quanta in Bit Segment 2) + 1 = 9 bit9Bit * Time Quantum = 9 * 444.444ns = 4000ns1/4000ns = 250kHz CAN通信的波特率必须完全匹配，硬线上可能会出现负电压。 2019.9.23:STM32CubeMX中有一项配置，自动重传：配置的期望和代码生成的结果正好是相反的，一定要注意。","link":"/2019/09/10/STM32 HAL库CAN注意点/"},{"title":"OpenOCD在虚拟机中的使用","text":"问题 在Vmware的ESXI虚拟机中使用OpenOCD的时候，一直提示找不到STM32的仿真器。 在系统硬件中可以看到连接的USB设备。 OpenOCD已经是最新版本20200310。 原因 经过查找后，确定原因是OpenOCD使用的libusb不能透过非libusb驱动的hub（恰好这是vmware实现USB映射的方法）找到此hub之下的libusb设备。 补充一个链接。 解决方法 经测试，最新版本的libusb已经支持了在hub下的设备遍历。测试方法就是下载最新版本的libusb并执行遍历的测试，可以看到设备。显然旧版本的看不到。 确定办法就是重新编译最新版本的OpenOCD，并且替换为最新版本的libusb。（注意要先用cygwin安装libusb，然后替换libusb） 编译步骤（参考此处）： 但是注意到编译过程中可能出现一些错误，原因是windows下这个cygwin编译器和makefile不匹配，在Makefile里找到-Wxxxx关闭就可以了。 当然由于目录设置的问题，OpenOCD要放在C盘根目录下，还要调整编译选项：C:\\OpenOCD。 说了这么多，太麻烦了。 链接：https://pan.baidu.com/s/11m8PbTbFTZYaSNV9kcsD6g 提取码：na3f 复制这段内容后打开百度网盘手机App，操作更方便哦","link":"/2020/04/02/OpenOCD在虚拟机中使用/"},{"title":"Raspberry PI长期运行配置","text":"背景 在家用树莓派3B做小型NAS以及frp跳板机，半年左右树莓派SD卡就会损坏。 总共损坏过三次。近一年前终于忍受不了，详细找了原因解决了问题，希望后面的人不要踩坑。 原因 分析和查找资料后，认为问题基本是因为SD卡反复读写导致的卡损坏。 选择适的存储介质 有条件使用EMMC时使用EMMC（需要工业级的CM3/CM3+）； 无条件时采用长寿命的高耐用的监控用SD卡。 文件系统配置 尽量使用Ext4文件系统，至少在Ext3以上，因为它们有日志功能，能降低文件系统损坏的风险。 Ext4文件系统具有日志功能，以及Barrier，快速系统检查功能，详见文件系统进化但是Ext4仍然可能造成文件丢失。 更改文件系统日志模式data=journal，会有更高的可靠性，损失一部分系统性能。 1234nano /boot/cmdline.txt添加rootflags=data=journal 值得注意的是默认提交metadata时间是五秒： 也就是说，5秒内的工作有可能丢失；但因为日志系统存在，文件系统正常不会损坏。 修改/boot/cmdline.txt 123nano /boot/cmdline.txt添加fsck.repair=yes 最后的cmdline.txt文件： 1dwc_otg.lpm_enable=0 root=PARTUUID=0cb3856c-02 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait rootflags=data=journal 关闭SWAP分区 SWAP分区是Linux用作虚拟内存的分区磁盘，Raspberry CM3/3B中使用的内存有1GB之大，不需要使用SWAP分区。 1234567891011121314# 切换到root帐号sudo su# 使用systemd关闭swap分区systemctl disable dphys-swapfilesystemctl stop dphys-swapfilesystemctl status dphys-swapfile# 查看内存使用情况，swap内为0free -mh total used free shared buff/cache availableMem: 875M 27M 779M 11M 67M 786MSwap: 0B 0B 0B 关闭系统日志转发 RASPBIAN系统日志由三部分组成： systemd-journald 此服务收集内核、进程stdout、stderr的消息，并写入/run下的临时文件，/run/log是tmpfs，不会使用磁盘IO。 可调整其存储策略以及占用限制。 在此调整ForwardToSyslog=no，关闭持久化转发，这样会降低IO，但是损失很久之前的log信息。 12345678910111213141516171819202122232425262728293031323334nano /etc/systemd/journald.conf[Journal]#Storage=auto#Compress=yes#Seal=yes#SplitMode=uid#SyncIntervalSec=5m#RateLimitIntervalSec=30s#RateLimitBurst=1000SystemMaxUse=100MSystemKeepFree=1GSystemMaxFileSize=20MSystemMaxFiles=100RuntimeMaxUse=100MRuntimeKeepFree=1GRuntimeMaxFileSize=20MRuntimeMaxFiles=100MaxRetentionSec=3dayMaxFileSec=3dayForwardToSyslog=no#ForwardToKMsg=no#ForwardToConsole=no#ForwardToWall=yes#TTYPath=/dev/console#MaxLevelStore=debug#MaxLevelSyslog=debug#MaxLevelKMsg=notice#MaxLevelConsole=info#MaxLevelWall=emerg# 然后重启日志服务systemctl restart systemd-journald rsyslog 这部分文件存在/var/log下，是磁盘数据，会占用磁盘空间和IO资源。 因为我们已经关闭了systemd-journald向rsyslog的转发功能，不需要再调整rsyslog的配置。 配置文件： 1nano /etc/rsyslog.conf rsyslog可以通过配置，设置过滤规则，转发规则，文件名等规则。 logrotate 这个服务是日志轮转功能，将rsyslog存下的日志文件定期轮转，可以不用动。 配置文件： 12345678910111213141516171819202122232425262728293031323334nano /etc/logrotate.conf# see &quot;man logrotate&quot; for details# rotate log files weeklydaily# keep 4 weeks worth of backlogsrotate 4# create new (empty) log files after rotating old onescreate# uncomment this if you want your log files compressedcompress# packages drop log rotation information into this directoryinclude /etc/logrotate.d# no packages own wtmp, or btmp -- we&apos;ll rotate them here/var/log/wtmp { missingok monthly create 0664 root utmp rotate 1}/var/log/btmp { missingok monthly create 0660 root utmp rotate 1}# system-specific logs may be configured here REDIS等中间件的持久化配置 中间件会定期向磁盘写入文件，以保证数据持久化，可关闭此功能，将save段全部注释： 123456789nano /etc/redis/redis.conf...# save 900 1# save 300 10# save 60 10000... 应用log配置 自定义的应用程序尽量采用向stdout和stderr流写入数据的方式存储log，使用systemd-journald控制log流转，而不是自定义log文件。 写在最后 最后上个图","link":"/2019/07/20/Raspberry PI长期运行配置/"},{"title":"STM32 HAL库ADC注意点","text":"现象 ADC线性度差；起始采样有50mV永远是0。 需要注意的问题 要求不高的不需要校准。 STM32的ADC精度较差，有多种校准方式。 小型芯片没有VREF引脚，可外置基准源到某采样通道上，按比例消除电源电压不准确的问题； 大型芯片可以外接基准源； 需要注意地平面平稳，电源平稳，ADC电源和地平面等硬件稳定； 需要减小进入ADC的输入阻抗，延长采样时间； ADC启动前，调用自校准函数，消除SAL不同电容上的漂移； 1HAL_ADCEx_Calibration_Start(&amp;hadc1); 这样校准下来，才能达到STM32宣称的12位水平，基本上10位是准确的。 内部的1.2V基准并不准确，有一个VREFINT_CAL寄存器会在出厂时提供这个参数，但是103系列没有这个基本参数，其它系列可能有。","link":"/2019/09/10/STM32 HAL库ADC注意点/"},{"title":"STM32 HAL库I2C注意点","text":"现象 STM32CubeMX提供了串口的HAL库，I2C有时候会卡死 原因 固件bug，网上搜到有很多，ST官方也承认的 解决方法 发送接收设置超时，并在之前检测状态 在函数调用 12HAL_I2C_Mem_Write()HAL_I2C_Mem_Read() 时设置超时参数 并在每次执行前尝试复位 12345if ((__HAL_I2C_GET_FLAG(&amp;hi2c2, I2C_FLAG_BUSY) ? SET : RESET) == SET) { __HAL_RCC_I2C2_FORCE_RESET(); __HAL_RCC_I2C2_RELEASE_RESET(); MX_I2C2_Init();} 不需要其它操作了","link":"/2019/07/19/STM32 HAL库I2C注意点/"},{"title":"在社区版Seafile中使用AD认证","text":"部署方式 根据Seafile官网指导，使用docker部署7.0.5版本的Seafile社区版。 修改 Seafile提供了LDAP认证功能，但根据官方指导直接配置ccnet.cnf后会启动不成功， Dockerfile： 12FROM seafileltd/seafile-mc:7.0.5RUN ln -s /usr/lib /usr/lib64 docker-compose.yml： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849version: &apos;3.7&apos;services: db: image: mariadb:10.1 container_name: seafile-mysql environment: - MYSQL_ROOT_PASSWORD=db_dev # Requested, set the root&apos;s password of MySQL service. - MYSQL_LOG_CONSOLE=true volumes: - /{{your_data_dir}}/seafile-mysql/db:/var/lib/mysql # Requested, specifies the path to MySQL data persistent store. networks: - seafile-net restart: always memcached: image: memcached:1.5.6 container_name: seafile-memcached entrypoint: memcached -m 256 networks: - seafile-net restart: always seafile: build: . image: seafile-with-ldap container_name: seafile-inside ports: - &quot;{{your_ip}}:443:443&quot; # If https is enabled, cancel the comment. volumes: - /{{your_data_dir}}/seafile-data:/shared # Requested, specifies the path to Seafile data persistent store. environment: - DB_HOST=db - DB_ROOT_PASSWD=db_dev # Requested, the value shuold be root&apos;s password of MySQL service. - TIME_ZONE=Asia/Shanghai # Optional, default is UTC. Should be uncomment and set to your local time zone. - SEAFILE_ADMIN_EMAIL=root # Specifies Seafile admin user, default is &apos;me@example.com&apos;. - SEAFILE_ADMIN_PASSWORD={{root_password}} # Specifies Seafile admin password, default is &apos;asecret&apos;. - SEAFILE_SERVER_LETSENCRYPT=true # Whether to use https or not. - SEAFILE_SERVER_HOSTNAME={{your_domain}} # Specifies your host name if https is enabled. depends_on: - db - memcached networks: - seafile-net restart: alwaysnetworks: seafile-net: 诊断LDAP配置： 查看log文件，我记得是seafile-data/logs/seafile/ccnet.log","link":"/2020/02/01/在社区版Seafile中使用AD认证/"},{"title":"人类控制和自动控制系统的区别","text":"为什么我要XJB想这个问题？ 思考自动控制那么强大那么成功，和教系统拧螺丝差在哪啊？ Google检索到 The difference between human control system and automatic control system: [1] In manual control system, the process operator observes the process condition and controls the system by doing manual adjustments. The Automatic control system uses any one of the continuous controller (P, PI, PID) to control the process based on the measurements and input.What make human being difference between machine: [2] 1. Machines do not have life, as they are mechanical. On the other hand, humans are made of flesh and blood; life is not mechanical for humans. 2. Humans have feelings and emotions, and they can express these emotions. Machines have no feelings and emotions. They just work as per the details fed into their mechanical brain. 3. Humans can do anything original, and machines cannot. 4. Humans have the capability to understand situations, and behave accordingly. On the contrary, machines do not have this capability. 5. While humans behave as per their consciousness, machines just perform as they are taught. 6. Humans perform activities as per their own intelligence. On the contrary, machines only have an artificial intelligence1 引用 [1] https://www.quora.com/What-is-the-difference-between-an-automatic-control-and-a-manual-control-system[2] https://www.quora.com/What-is-the-difference-between-an-automatic-control-and-a-manual-control-system","link":"/2019/10/09/人类控制和自动控制系统的区别/"},{"title":"STM32 HAL库串口注意点","text":"现象 STM32CubeMX提供了串口的HAL库，网上能找到很多例子，但是真正运行起来会时不时卡死。 原因 代码中使用了在 1void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) 函数中调用 1HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size) 重新启动中断，并将数据送入队列的方法。 会造成两个问题： HAL_UART_Receive_IT中检测__HAL_LOCK(huart)，中断外调用HAL_UART_Transmit时也会锁定此huart，再进入接收中断时有几率造成死锁。发生OverRun错误会停止中断。 解决方法 定期检测串口，防止死锁造成的无法恢复的失败。写好HAL_UART_ErrorCallback函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// define and initial variables outsideextern UART_HandleTypeDef huart3;volatile char data;extern osMessageQId rxQHandle;void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart){ if (huart-&gt;Instance == USART3){ BaseType_t xHigherPriorityTaskWoken; xHigherPriorityTaskWoken = pdTRUE; xQueueSendFromISR(rxQHandle, (void*)&amp;data, &amp;xHigherPriorityTaskWoken); if (HAL_UART_Receive_IT(huart, (uint8_t*)&amp;data ,1) != HAL_OK){ // fail ++; } }}void HAL_UART_ErrorCallback(UART_HandleTypeDef* huart){ uint32_t isrflags = READ_REG(huart-&gt;Instance-&gt;SR); if((__HAL_UART_GET_FLAG(huart, UART_FLAG_PE))!=RESET) { __HAL_UART_CLEAR_PEFLAG(huart); } if((__HAL_UART_GET_FLAG(huart, UART_FLAG_FE))!=RESET) { __HAL_UART_CLEAR_FEFLAG(huart); } if((__HAL_UART_GET_FLAG(huart, UART_FLAG_NE))!=RESET) { __HAL_UART_CLEAR_NEFLAG(huart); } if((__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE))!=RESET) { __HAL_UART_CLEAR_OREFLAG(huart); } huart-&gt;RxState = HAL_UART_STATE_READY; huart-&gt;ErrorCode = HAL_UART_ERROR_NONE; __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE); __HAL_UART_DISABLE_IT(huart, UART_IT_PE); __HAL_UART_DISABLE_IT(huart, UART_IT_ERR); if (huart-&gt;Instance == USART3){ if (HAL_UART_Receive_IT(huart, (uint8_t*)&amp;data ,1) != HAL_OK){ } }}void call_this_function_periodically(ali_cloud* app){ if ((__HAL_UART_GET_FLAG(&amp;huart3, UART_FLAG_ORE) != RESET) || (huart3.Instance-&gt;CR1 &amp; USART_CR1_RXNEIE == RESET)) { __disable_irq(); HAL_UART_ErrorCallback(&amp;huart3); __enable_irq(); }} 总结 STM32的用户较少，网上资料不可轻信，使用任何外设都要详细查找坑的所在。 STM32的官方资料不全。 简单的东西出现小问题也很耗时间，还是需要熟悉各种细节的人相互配合。","link":"/2019/07/19/STM32 HAL库串口注意点/"},{"title":"Hexo常用命令","text":"Hexo介绍 Hexo是本博客使用的前端系统，文章记录常用命令，待将来查询使用。 教程收集 12https://hexo.io/zh-cn/docs/commands.htmlhttps://segmentfault.com/a/1190000002632530 常用命令 123456npm install hexo -gnpm update hexo -ghexo inithexo shexp ghexo d","link":"/2019/09/02/Hexo常用命令/"},{"title":"人类控制和自动控制系统的区别","text":"Google检索到 Some believe that social structure is naturally developed. It may be caused by larger system needs, such as the need for labour, management, professional and military classes, or by conflicts between groups, such as competition among political parties or among elites and masses.[1] 1 引用 [1] https://en.wikipedia.org/wiki/Social_structure","link":"/2019/10/30/为什么社会会形成组织结构/"},{"title":"流水线劳动需要的智力思考","text":"为什么我要XJB想这个问题？ 人类从原始社会采集野果，追捕猎物到农耕时代、驯化野兽，到现代的机械化大生产，一步步摆脱了繁杂的劳动。 到今天，人们的一大梦想就是就是解放类似流水线人工、扫地等等低智力劳动的工作；同时，在这个过程中，由于生产效率的提升，会创造巨大的价值，产生巨大的财富。无论从精神或者物质方面，进一步解放生产力都是人们梦寐以求的进步。 从深度学习到人脸识别到自动驾驶，科学家和工程技术人员取得了一个又一个的成功。 然而，我本人特别看好利用机器代替流水线工人的工作这类研究和应用。 曾经在风机叶片厂工作过几天，这让我印象深刻。工人处于充满粉尘的厂房里，干着又脏又累的重体力劳动，他们愿意吗？不得不愿意，生存的重担已经压遍了人们本能的厌恶。 几种聪明的动物能不能上流水线拧螺丝？ 从拧螺丝这个简单的动作出发，先不考虑要求的力矩，只分析把螺丝死死地拧上。 猫：显然不可能啦，你家猫主子再怎么培训也没有手拧。 狗：据称聪明的狗能达到6-7岁的人类智力水平，那么显然一个快上小学的娃是能学会拧螺丝的，而且狗很听话。 猩猩：大概可以吧？我没怎么看过猩猩的视频，但是我知道它们能学会用手势告诉人应该干什么，而且重要的是他们有手。 猪：它们虽然聪明但是没有手……大概只能被人类吃。 大象：同样没有手，有鼻子但是不够灵巧。 小孩子：能学会，但是他们贪玩，并不是所有的小孩子都能干好，他们爱跑来跑去玩。 总结一下：拧螺丝这个简单的动作，需要几个最基本的条件： 1234有类似人类的手脚有相应的智力水平能够被驯服能够专注有约束 换句话说： 1234有合适的执行机构有相应的控制器控制器能实现控制目标控制器不超出边界条件 好吧，总结了半天，说的全是废话。","link":"/2019/10/09/流水线劳动需要的智力/"},{"title":"阿里云iotkit-embedded的坑","text":"硬件配置 STM32F103RCT6 (RAM 64kB, FLASH: 256kB)SIM800C 软件配置 STM32CubeMX 配置 FreeRTOSiotkit-embedded阿里云移植demo iotkit-embedded配置 参考阿里云给出的demo，使用 1make menuconfig 配置 配置时参考阿里云Demo，但要注意： 不要使能PLATFORM_HAS_DYNMEM 频繁从FreeRTOS内部申请内存没有必要，固定内存区域更安全 FreeRTOS调度申请内存有很多种算法，我并不能完全了解 不要使能PLATFORM_HAS_OS 貌似这部分代码在本文写出时还不太完善 SIM800C初始化部分需要改造，频繁申请Mutex和Semaphore 不要使用OTA功能 没有SSL，玩不起来 配置完成后编译时缺个log库，include删除就好 移植 移植wrapper.c 把所有的Mutex和Semaphore相关的函数全部返回正常（看一下头部说明）一定要实现HAL_Snprintf，参考HAL_SleepMS使用osDelay实现Malloc使用pvPortMalloc(), HAL_Free使用vPortFree() 不得不说的是，即使你关闭了PLATFORM_HAS_DYNMEM，iotkit-embedded还是会调用这个函数，我记得出现在上报版本信息这个函数中 HAL_AT_Uart_Send使用HAL_UART_Transmit_IT连续发送，并在发送结束后判断gState，使用osDelay让出时间片HAL_AT_Uart_Recv使用STM32串口文章中所提的方法，用队列接收，并自定义超时注意一下iotx_mqtt_config.h中的IOTX_MC_TX_MAX_LEN以及IOTX_MC_RX_MAX_LEN，数据千万不要超了，或者修改宏定义，不然找都找不到在哪出错CONFIG_MQTT_TOPIC_MAXLEN这个最大的topic长度八成不够长，自己改下就好。最最重要的一个坑： 千万不要把example_publish这个函数中的内容分成几个函数块调用原因是IOT_MQTT_Construct(&amp;mqtt_params)这个函数内会直接使用mqtt_params的字符串，并保存；当你再使用yield以及publish这些函数时，有可能会重新连接，造成野指针程序跑飞。 重启SIM800C 担心SIM800C会挂，以及网络失败，需要hack一下代码 定时以及发现一直连接失败时重启sim800C只需要改造IOT_ATM_Init以及它调用的函数 忽略at_parser_init返回的错误设置reset_sim800c标签，在at_conn_init内重置at_conn_init_done（因为要把atconnects重置）HAL_AT_CONN_Init内重置inited，这样它会重新检测sim800的状态。 总结 暂时只能想起这么多了，如果有遗漏那么抱歉了。。 开源库不是那么好用，想用上，是要付出代价的。 解释 为什么不提PR？ 因为大部分其实不是bug，只是没有相关文档，我们不知道而已。 为什么不放出代码？ 公司代码。","link":"/2019/07/19/阿里云iotkit-embedded的坑/"},{"title":"抢占式任务配置","text":"背景 以前做项目使用Raspberry PI CM3 + RT Preempt做实时控制，这部分需要对系统和任务进行特殊的配置。 系统补丁 需要先将原内核替换为抢占式内核，这个在树莓派官方github内就有相应的rt版本内核，找步骤替换即可。 CPU隔离 CPU隔离就是将树莓派的四个CPU的其中一个从Linux系统的调度名单中划去，以便为我们实时任务服务。 修改/boot/cmdline.txt 1234nano /boot/cmdline.txt添加isolcpus=3 验证： 1234apt install systbenchsysbench --test=cpu --cpu-max-prime=20000 --num-threads=4 runtop 结果： 123456789101112131415161718Tasks: 126 total, 2 running, 83 sleeping, 0 stopped, 0 zombie%Cpu0 : 87.8 us, 12.2 sy, 0.0 ni, 0.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st%Cpu1 :100.0 us, 0.0 sy, 0.0 ni, 0.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st%Cpu2 : 85.4 us, 14.6 sy, 0.0 ni, 0.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st%Cpu3 : 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 896152 total, 711340 free, 31848 used, 152964 buff/cacheKiB Swap: 102396 total, 102396 free, 0 used. 804976 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 817 root 20 0 8628 1636 1364 S 260.5 0.2 3:16.75 sysbench 486 root -51 0 0 0 0 S 7.0 0.0 0:19.05 irq/170-mcp251x 823 root 20 0 8204 3384 2852 R 7.0 0.4 0:00.11 top 81 root 20 0 0 0 0 I 4.7 0.0 0:04.10 kworker/0:2 28 root -2 0 0 0 0 S 2.3 0.0 0:00.30 ktimersoftd/2 86 root 20 0 0 0 0 S 2.3 0.0 0:03.22 spi0 87 root -51 0 0 0 0 S 2.3 0.0 0:00.23 irq/169-enc28j6 456 root 20 0 0 0 0 I 2.3 0.0 0:00.76 kworker/2:3 781 root 20 0 11652 5816 5096 S 2.3 0.6 0:00.44 sshd 在4线程CPU benchmark测试下，CPU3未被调度。 用户隔离 为实时进程添加新用户，并禁用登录： 12adduser rttaskpasswd -l rttask SYSTEMD配置 几个注意点： User=rttask 设置用户隔离 Nice=-20 设置用户态最高优先级 CPUAffinity=3 设置CPU亲和性 资源限制 文件位置： 1/lib/systemd/system/rttask.service 内容： 12345678910111213141516171819[Unit]Description=real time taskAfter=network.service redis.service[Service]Type=simpleUser=rttaskWorkingDirectory=/root/debug/webExecStart=/root/debug/web/rttaskRestart=alwaysStartLimitInterval=0Nice=-20CPUAffinity=3MemoryMax=100MCPUQuota=200%[Install]WantedBy=default.target 启动、自启动命令： 1234systemctl daemon-reloadsystemctl start rttasksystemctl enable rttask 其它命令： 123systemctl stop rttasksystemctl disable rttasksystemctl restart rttask","link":"/2019/07/21/抢占式任务配置/"},{"title":"Vue.js学习-命令记录","text":"Vue.js介绍 Vue.js是一个流行的前端框架。 教程收集 123456https://vuejs.org/https://cli.vuejs.org/https://vuetifyjs.com/en/getting-started/quick-starthttps://vuejs.org/v2/guide/routing.htmlhttps://www.youtube.com/playlist?list=PLu3b11EPo_MfxhGAgO1LTJuDLTMCHIGLvhttps://www.youtube.com/watch?v=4deVCNJq3qc&amp;list=PLkdRA6Qj9ZLLdGArM6bLnnMeH3rH82MEL&amp;index=2&amp;t=0s 基本命令 123456789101112# 提前安装node.js npm# 安装vue.js命令行npm install -g @vue/cli # 创建工程mkdir projectcd projectvue create .# 添加组件vue add vuexvue add vuetifyvue add eslintvue add router","link":"/2019/09/02/Vue.js学习-命令记录/"},{"title":"流水线劳动需要的智力思考","text":"为什么我要XJB想这个问题？ 人类从原始社会采集野果，追捕猎物到农耕时代、驯化野兽，到现代的机械化大生产，一步步摆脱了繁杂的劳动。 到今天，人们的一大梦想就是就是解放类似流水线人工、扫地等等低智力劳动的工作；同时，在这个过程中，由于生产效率的提升，会创造巨大的价值，产生巨大的财富。无论从精神或者物质方面，进一步解放生产力都是人们梦寐以求的进步。 从深度学习到人脸识别到自动驾驶，科学家和工程技术人员取得了一个又一个的成功。 然而，我本人特别看好利用机器代替流水线工人的工作这类研究和应用。 曾经在风机叶片厂工作过几天，这让我印象深刻。工人处于充满粉尘的厂房里，干着又脏又累的重体力劳动，他们愿意吗？不得不愿意，生存的重担已经压遍了人们本能的厌恶。 几种聪明的动物能不能上流水线拧螺丝？ 从拧螺丝这个简单的动作出发，先不考虑要求的力矩，只分析把螺丝死死地拧上。 猫：显然不可能啦，你家猫主子再怎么培训也没有手拧。 狗：据称聪明的狗能达到6-7岁的人类智力水平，那么显然一个快上小学的娃是能学会拧螺丝的，而且狗很听话。 猩猩：大概可以吧？我没怎么看过猩猩的视频，但是我知道它们能学会用手势告诉人应该干什么，而且重要的是他们有手。 猪：它们虽然聪明但是没有手……大概只能被人类吃。 大象：同样没有手，有鼻子但是不够灵巧。 小孩子：能学会，但是他们贪玩，并不是所有的小孩子都能干好，他们爱跑来跑去玩。 总结一下：拧螺丝这个简单的动作，需要几个最基本的条件： 1234有类似人类的手脚有相应的智力水平能够被驯服能够专注有约束 换句话说： 1234有合适的执行机构有相应的控制器控制器能实现控制目标控制器不超出边界条件` 好吧，总结了半天，说的全是废话。","link":"/2019/10/09/控制系统的限制条件/"},{"title":"SOC SOH估计","text":"问题 电池管理系统常用在各个场合，如手机、电脑、功率电力电子设备。SOC(State of charge)与SOH(State of health)估计是需要实现的两个重要算法。 芯片方案 BQ34Z100-G1: 1http://www.ti.com.cn/product/cn/BQ34Z100-G1 还有其它方案，原理类似。采用高精度的ADC做电荷计，对电池内电荷进行准确计数（安时积分）；同时输入电池的测试曲线，用以作为基准，采用逻辑进行校正，具体见bq34z100-g1的算法文档。只需要会使用芯片就可以了，门槛低，也是最常用应用最多的方案。因为没有动态特性的跟踪，误差较大，可能达20%。[1] 扩展卡尔曼滤波 扩展卡尔曼滤波是对非线性系统进行在线参数估计的一种算法，它用在BMS系统中十分适用，据多篇文献，可达到较高精度1%之内[1]。 这有两种方法： 方法一是对系统所有的参数都进行建模（建模参考[2]），然后直接把所有参数进行在线扩展卡尔曼滤波[1]，获取准确的系统参数。这种方法据称准确度较高，我不负责任地评估一下，它的稳定性可能较差，为了获取所有的参数，系统需要经历比较全面的动态过程，这在实际工作状态下是很难实现的；同时在MCU内的计算需求大。 方法二是对系统的动态参数提前进行建模以及测试，然后在线仅实现卡尔曼滤波对电池内阻在线跟踪。建模仍然参考[2]。 先对一阶的系统进行建模，对电池动态特性中的每个参数都作为被估计的参数，进行建模，然后进行最小二乘拟合，获取不同情况下的电池参数。 为了实现较高的跟踪精度，仍需要对电池在不同温度、不同SOC情况下的动态特性进行建模，具体说来就是将把电池在不同SOC（0%到100%，step 10%）下进行脉冲放电，并计算它的动态参数，获取离线参数表。 然后在线实现内阻跟踪。 估计可以达到很高的精度以及很高的稳定性及较小的计算需求。 其它设计参考 Hack Tesla BMS： 1https://hackaday.io/project/10098-model-s-bms-hacking Matlab： 1https://ww2.mathworks.cn/solutions/power-electronics-control/battery-models.html 参考文献 [1] Andre, Dave, et al. “Advanced mathematical methods of SOC and SOH estimation for lithium-ion batteries.” Journal of power sources 224 (2013): 20-27.[2] He, Hongwen, Rui Xiong, and Hongqiang Guo. “Online estimation of model parameters and state-of-charge of LiFePO4 batteries in electric vehicles.” Applied Energy 89.1 (2012): 413-420.[3] Cheng, Ka Wai Eric, et al. “Battery-management system (BMS) and SOC development for electrical vehicles.” IEEE transactions on vehicular technology 60.1 (2010): 76-88.[4] Plett, Gregory L. “Extended Kalman filtering for battery management systems of LiPB-based HEV battery packs: Part 3. State and parameter estimation.” Journal of Power sources 134.2 (2004): 277-292.[5] Yu, Zhihao, Ruituo Huai, and Linjing Xiao. “State-of-charge estimation for lithium-ion batteries using a kalman filter based on local linearization.” Energies 8.8 (2015): 7854-7873.[6] Huang, Shyh-Chin, et al. “An online SOC and SOH estimation model for lithium-ion batteries.” Energies 10.4 (2017): 512.[7] Zhang, Ruifeng, et al. “State of the art of lithium-ion battery soc estimation for electrical vehicles.” Energies 11.7 (2018): 1820.[8] Hoshiya, Masaru, and Etsuro Saito. “Structural identification by extended Kalman filter.” Journal of engineering mechanics 110.12 (1984): 1757-1770.[9] Ljung, Lennart. “Asymptotic behavior of the extended Kalman filter as a parameter estimator for linear systems.” IEEE Transactions on Automatic Control 24.1 (1979): 36-50.[10] Welch, Greg, and Gary Bishop. “An introduction to the Kalman filter.” (1995): 41-95.","link":"/2019/09/02/SOC&SOH估算/"}],"tags":[{"name":"STM32","slug":"STM32","link":"/tags/STM32/"},{"name":"嵌入式","slug":"嵌入式","link":"/tags/嵌入式/"},{"name":"技术","slug":"技术","link":"/tags/技术/"},{"name":"软件配置","slug":"软件配置","link":"/tags/软件配置/"},{"name":"RaspberryPI","slug":"RaspberryPI","link":"/tags/RaspberryPI/"},{"name":"胡想思想","slug":"胡想思想","link":"/tags/胡想思想/"},{"name":"做一个民科","slug":"做一个民科","link":"/tags/做一个民科/"},{"name":"前端","slug":"前端","link":"/tags/前端/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"物联网","slug":"物联网","link":"/tags/物联网/"},{"name":"Vue.js","slug":"Vue-js","link":"/tags/Vue-js/"},{"name":"电力电子","slug":"电力电子","link":"/tags/电力电子/"},{"name":"算法","slug":"算法","link":"/tags/算法/"}],"categories":[{"name":"STM32","slug":"STM32","link":"/categories/STM32/"},{"name":"HAL库","slug":"STM32/HAL库","link":"/categories/STM32/HAL库/"},{"name":"软件配置","slug":"软件配置","link":"/categories/软件配置/"},{"name":"RaspberryPI","slug":"RaspberryPI","link":"/categories/RaspberryPI/"},{"name":"胡想思想","slug":"胡想思想","link":"/categories/胡想思想/"},{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"物联网","slug":"物联网","link":"/categories/物联网/"},{"name":"嵌入式上云","slug":"物联网/嵌入式上云","link":"/categories/物联网/嵌入式上云/"},{"name":"电力电子","slug":"电力电子","link":"/categories/电力电子/"}]}