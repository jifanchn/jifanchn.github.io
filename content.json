{"pages":[],"posts":[{"title":"SOC SOH估计","text":"问题 电池管理系统常用在各个场合，如手机、电脑、功率电力电子设备。SOC(State of charge)与SOH(State of health)估计是需要实现的两个重要算法。 芯片方案 BQ34Z100-G1: 1http://www.ti.com.cn/product/cn/BQ34Z100-G1 还有其它方案，原理类似。采用高精度的ADC做电荷计，对电池内电荷进行准确计数（安时积分）；同时输入电池的测试曲线，用以作为基准，采用逻辑进行校正，具体见bq34z100-g1的算法文档。只需要会使用芯片就可以了，门槛低，也是最常用应用最多的方案。因为没有动态特性的跟踪，误差较大，可能达20%。[1] 扩展卡尔曼滤波 扩展卡尔曼滤波是对非线性系统进行在线参数估计的一种算法，它用在BMS系统中十分适用，据多篇文献，可达到较高精度1%之内[1]。 这有两种方法： 方法一是对系统所有的参数都进行建模（建模参考[2]），然后直接把所有参数进行在线扩展卡尔曼滤波[1]，获取准确的系统参数。这种方法据称准确度较高，我不负责任地评估一下，它的稳定性可能较差，为了获取所有的参数，系统需要经历比较全面的动态过程，这在实际工作状态下是很难实现的；同时在MCU内的计算需求大。 方法二是对系统的动态参数提前进行建模以及测试，然后在线仅实现卡尔曼滤波对电池内阻在线跟踪。建模仍然参考[2]。 先对一阶的系统进行建模，对电池动态特性中的每个参数都作为被估计的参数，进行建模，然后进行最小二乘拟合，获取不同情况下的电池参数。 为了实现较高的跟踪精度，仍需要对电池在不同温度、不同SOC情况下的动态特性进行建模，具体说来就是将把电池在不同SOC（0%到100%，step 10%）下进行脉冲放电，并计算它的动态参数，获取离线参数表。 然后在线实现内阻跟踪。 估计可以达到很高的精度以及很高的稳定性及较小的计算需求。 其它设计参考 Hack Tesla BMS： 1https://hackaday.io/project/10098-model-s-bms-hacking Matlab： 1https://ww2.mathworks.cn/solutions/power-electronics-control/battery-models.html 参考文献 [1] Andre, Dave, et al. “Advanced mathematical methods of SOC and SOH estimation for lithium-ion batteries.” Journal of power sources 224 (2013): 20-27.[2] He, Hongwen, Rui Xiong, and Hongqiang Guo. “Online estimation of model parameters and state-of-charge of LiFePO4 batteries in electric vehicles.” Applied Energy 89.1 (2012): 413-420.[3] Cheng, Ka Wai Eric, et al. “Battery-management system (BMS) and SOC development for electrical vehicles.” IEEE transactions on vehicular technology 60.1 (2010): 76-88.[4] Plett, Gregory L. “Extended Kalman filtering for battery management systems of LiPB-based HEV battery packs: Part 3. State and parameter estimation.” Journal of Power sources 134.2 (2004): 277-292.[5] Yu, Zhihao, Ruituo Huai, and Linjing Xiao. “State-of-charge estimation for lithium-ion batteries using a kalman filter based on local linearization.” Energies 8.8 (2015): 7854-7873.[6] Huang, Shyh-Chin, et al. “An online SOC and SOH estimation model for lithium-ion batteries.” Energies 10.4 (2017): 512.[7] Zhang, Ruifeng, et al. “State of the art of lithium-ion battery soc estimation for electrical vehicles.” Energies 11.7 (2018): 1820.[8] Hoshiya, Masaru, and Etsuro Saito. “Structural identification by extended Kalman filter.” Journal of engineering mechanics 110.12 (1984): 1757-1770.[9] Ljung, Lennart. “Asymptotic behavior of the extended Kalman filter as a parameter estimator for linear systems.” IEEE Transactions on Automatic Control 24.1 (1979): 36-50.[10] Welch, Greg, and Gary Bishop. “An introduction to the Kalman filter.” (1995): 41-95.","link":"/2019/09/02/SOC&SOH估算/"},{"title":"Hexo常用命令","text":"Hexo介绍 Hexo是本博客使用的前端系统，文章记录常用命令，待将来查询使用。 教程收集 12https://hexo.io/zh-cn/docs/commands.htmlhttps://segmentfault.com/a/1190000002632530 常用命令 123456npm install hexo -gnpm update hexo -ghexo inithexo shexp ghexo d","link":"/2019/09/02/Hexo常用命令/"},{"title":"Raspberry PI长期运行配置","text":"背景 在家用树莓派3B做小型NAS以及frp跳板机，半年左右树莓派SD卡就会损坏。 总共损坏过三次。近一年前终于忍受不了，详细找了原因解决了问题，希望后面的人不要踩坑。 原因 分析和查找资料后，认为问题基本是因为SD卡反复读写导致的卡损坏。 选择适的存储介质 有条件使用EMMC时使用EMMC（需要工业级的CM3/CM3+）； 无条件时采用长寿命的高耐用的监控用SD卡。 文件系统配置 尽量使用Ext4文件系统，至少在Ext3以上，因为它们有日志功能，能降低文件系统损坏的风险。 Ext4文件系统具有日志功能，以及Barrier，快速系统检查功能，详见文件系统进化但是Ext4仍然可能造成文件丢失。 更改文件系统日志模式data=journal，会有更高的可靠性，损失一部分系统性能。 1234nano /boot/cmdline.txt添加rootflags=data=journal 值得注意的是默认提交metadata时间是五秒： 也就是说，5秒内的工作有可能丢失；但因为日志系统存在，文件系统正常不会损坏。 修改/boot/cmdline.txt 123nano /boot/cmdline.txt添加fsck.repair=yes 最后的cmdline.txt文件： 1dwc_otg.lpm_enable=0 root=PARTUUID=0cb3856c-02 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait rootflags=data=journal 关闭SWAP分区 SWAP分区是Linux用作虚拟内存的分区磁盘，Raspberry CM3/3B中使用的内存有1GB之大，不需要使用SWAP分区。 1234567891011121314# 切换到root帐号sudo su# 使用systemd关闭swap分区systemctl disable dphys-swapfilesystemctl stop dphys-swapfilesystemctl status dphys-swapfile# 查看内存使用情况，swap内为0free -mh total used free shared buff/cache availableMem: 875M 27M 779M 11M 67M 786MSwap: 0B 0B 0B 关闭系统日志转发 RASPBIAN系统日志由三部分组成： systemd-journald 此服务收集内核、进程stdout、stderr的消息，并写入/run下的临时文件，/run/log是tmpfs，不会使用磁盘IO。 可调整其存储策略以及占用限制。 在此调整ForwardToSyslog=no，关闭持久化转发，这样会降低IO，但是损失很久之前的log信息。 12345678910111213141516171819202122232425262728293031323334nano /etc/systemd/journald.conf[Journal]#Storage=auto#Compress=yes#Seal=yes#SplitMode=uid#SyncIntervalSec=5m#RateLimitIntervalSec=30s#RateLimitBurst=1000SystemMaxUse=100MSystemKeepFree=1GSystemMaxFileSize=20MSystemMaxFiles=100RuntimeMaxUse=100MRuntimeKeepFree=1GRuntimeMaxFileSize=20MRuntimeMaxFiles=100MaxRetentionSec=3dayMaxFileSec=3dayForwardToSyslog=no#ForwardToKMsg=no#ForwardToConsole=no#ForwardToWall=yes#TTYPath=/dev/console#MaxLevelStore=debug#MaxLevelSyslog=debug#MaxLevelKMsg=notice#MaxLevelConsole=info#MaxLevelWall=emerg# 然后重启日志服务systemctl restart systemd-journald rsyslog 这部分文件存在/var/log下，是磁盘数据，会占用磁盘空间和IO资源。 因为我们已经关闭了systemd-journald向rsyslog的转发功能，不需要再调整rsyslog的配置。 配置文件： 1nano /etc/rsyslog.conf rsyslog可以通过配置，设置过滤规则，转发规则，文件名等规则。 logrotate 这个服务是日志轮转功能，将rsyslog存下的日志文件定期轮转，可以不用动。 配置文件： 12345678910111213141516171819202122232425262728293031323334nano /etc/logrotate.conf# see &quot;man logrotate&quot; for details# rotate log files weeklydaily# keep 4 weeks worth of backlogsrotate 4# create new (empty) log files after rotating old onescreate# uncomment this if you want your log files compressedcompress# packages drop log rotation information into this directoryinclude /etc/logrotate.d# no packages own wtmp, or btmp -- we&apos;ll rotate them here/var/log/wtmp { missingok monthly create 0664 root utmp rotate 1}/var/log/btmp { missingok monthly create 0660 root utmp rotate 1}# system-specific logs may be configured here REDIS等中间件的持久化配置 中间件会定期向磁盘写入文件，以保证数据持久化，可关闭此功能，将save段全部注释： 123456789nano /etc/redis/redis.conf...# save 900 1# save 300 10# save 60 10000... 应用log配置 自定义的应用程序尽量采用向stdout和stderr流写入数据的方式存储log，使用systemd-journald控制log流转，而不是自定义log文件。 写在最后 最后上个图","link":"/2019/07/20/Raspberry PI长期运行配置/"},{"title":"STM32 HAL库I2C注意点","text":"现象 STM32CubeMX提供了串口的HAL库，I2C有时候会卡死 原因 固件bug，网上搜到有很多，ST官方也承认的 解决方法 发送接收设置超时，并在之前检测状态 在函数调用 12HAL_I2C_Mem_Write()HAL_I2C_Mem_Read() 时设置超时参数 并在每次执行前尝试复位 12345if ((__HAL_I2C_GET_FLAG(&amp;hi2c2, I2C_FLAG_BUSY) ? SET : RESET) == SET) { __HAL_RCC_I2C2_FORCE_RESET(); __HAL_RCC_I2C2_RELEASE_RESET(); MX_I2C2_Init();} 不需要其它操作了","link":"/2019/07/19/STM32 HAL库I2C注意点/"},{"title":"STM32 HAL库串口注意点","text":"现象 STM32CubeMX提供了串口的HAL库，网上能找到很多例子，但是真正运行起来会时不时卡死。 原因 代码中使用了在 1void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) 函数中调用 1HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size) 重新启动中断，并将数据送入队列的方法。 会造成两个问题： HAL_UART_Receive_IT中检测__HAL_LOCK(huart)，中断外调用HAL_UART_Transmit时也会锁定此huart，再进入接收中断时有几率造成死锁。发生OverRun错误会停止中断。 解决方法 定期检测串口，防止死锁造成的无法恢复的失败。写好HAL_UART_ErrorCallback函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// define and initial variables outsideextern UART_HandleTypeDef huart3;volatile char data;extern osMessageQId rxQHandle;void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart){ if (huart-&gt;Instance == USART3){ BaseType_t xHigherPriorityTaskWoken; xHigherPriorityTaskWoken = pdTRUE; xQueueSendFromISR(rxQHandle, (void*)&amp;data, &amp;xHigherPriorityTaskWoken); if (HAL_UART_Receive_IT(huart, (uint8_t*)&amp;data ,1) != HAL_OK){ // fail ++; } }}void HAL_UART_ErrorCallback(UART_HandleTypeDef* huart){ uint32_t isrflags = READ_REG(huart-&gt;Instance-&gt;SR); if((__HAL_UART_GET_FLAG(huart, UART_FLAG_PE))!=RESET) { __HAL_UART_CLEAR_PEFLAG(huart); } if((__HAL_UART_GET_FLAG(huart, UART_FLAG_FE))!=RESET) { __HAL_UART_CLEAR_FEFLAG(huart); } if((__HAL_UART_GET_FLAG(huart, UART_FLAG_NE))!=RESET) { __HAL_UART_CLEAR_NEFLAG(huart); } if((__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE))!=RESET) { __HAL_UART_CLEAR_OREFLAG(huart); } huart-&gt;RxState = HAL_UART_STATE_READY; huart-&gt;ErrorCode = HAL_UART_ERROR_NONE; __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE); __HAL_UART_DISABLE_IT(huart, UART_IT_PE); __HAL_UART_DISABLE_IT(huart, UART_IT_ERR); if (huart-&gt;Instance == USART3){ if (HAL_UART_Receive_IT(huart, (uint8_t*)&amp;data ,1) != HAL_OK){ } }}void call_this_function_periodically(ali_cloud* app){ if ((__HAL_UART_GET_FLAG(&amp;huart3, UART_FLAG_ORE) != RESET) || (huart3.Instance-&gt;CR1 &amp; USART_CR1_RXNEIE == RESET)) { __disable_irq(); HAL_UART_ErrorCallback(&amp;huart3); __enable_irq(); }} 总结 STM32的用户较少，网上资料不可轻信，使用任何外设都要详细查找坑的所在。 STM32的官方资料不全。 简单的东西出现小问题也很耗时间，还是需要熟悉各种细节的人相互配合。","link":"/2019/07/19/STM32 HAL库串口注意点/"},{"title":"抢占式任务配置","text":"背景 以前做项目使用Raspberry PI CM3 + RT Preempt做实时控制，这部分需要对系统和任务进行特殊的配置。 系统补丁 需要先将原内核替换为抢占式内核，这个在树莓派官方github内就有相应的rt版本内核，找步骤替换即可。 CPU隔离 CPU隔离就是将树莓派的四个CPU的其中一个从Linux系统的调度名单中划去，以便为我们实时任务服务。 修改/boot/cmdline.txt 1234nano /boot/cmdline.txt添加isolcpus=3 验证： 1234apt install systbenchsysbench --test=cpu --cpu-max-prime=20000 --num-threads=4 runtop 结果： 123456789101112131415161718Tasks: 126 total, 2 running, 83 sleeping, 0 stopped, 0 zombie%Cpu0 : 87.8 us, 12.2 sy, 0.0 ni, 0.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st%Cpu1 :100.0 us, 0.0 sy, 0.0 ni, 0.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st%Cpu2 : 85.4 us, 14.6 sy, 0.0 ni, 0.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st%Cpu3 : 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 896152 total, 711340 free, 31848 used, 152964 buff/cacheKiB Swap: 102396 total, 102396 free, 0 used. 804976 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 817 root 20 0 8628 1636 1364 S 260.5 0.2 3:16.75 sysbench 486 root -51 0 0 0 0 S 7.0 0.0 0:19.05 irq/170-mcp251x 823 root 20 0 8204 3384 2852 R 7.0 0.4 0:00.11 top 81 root 20 0 0 0 0 I 4.7 0.0 0:04.10 kworker/0:2 28 root -2 0 0 0 0 S 2.3 0.0 0:00.30 ktimersoftd/2 86 root 20 0 0 0 0 S 2.3 0.0 0:03.22 spi0 87 root -51 0 0 0 0 S 2.3 0.0 0:00.23 irq/169-enc28j6 456 root 20 0 0 0 0 I 2.3 0.0 0:00.76 kworker/2:3 781 root 20 0 11652 5816 5096 S 2.3 0.6 0:00.44 sshd 在4线程CPU benchmark测试下，CPU3未被调度。 用户隔离 为实时进程添加新用户，并禁用登录： 12adduser rttaskpasswd -l rttask SYSTEMD配置 几个注意点： User=rttask 设置用户隔离 Nice=-20 设置用户态最高优先级 CPUAffinity=3 设置CPU亲和性 资源限制 文件位置： 1/lib/systemd/system/rttask.service 内容： 12345678910111213141516171819[Unit]Description=real time taskAfter=network.service redis.service[Service]Type=simpleUser=rttaskWorkingDirectory=/root/debug/webExecStart=/root/debug/web/rttaskRestart=alwaysStartLimitInterval=0Nice=-20CPUAffinity=3MemoryMax=100MCPUQuota=200%[Install]WantedBy=default.target 启动、自启动命令： 1234systemctl daemon-reloadsystemctl start rttasksystemctl enable rttask 其它命令： 123systemctl stop rttasksystemctl disable rttasksystemctl restart rttask","link":"/2019/07/21/抢占式任务配置/"},{"title":"Vue.js学习-命令记录","text":"Vue.js介绍 Vue.js是一个流行的前端框架。 教程收集 123456https://vuejs.org/https://cli.vuejs.org/https://vuetifyjs.com/en/getting-started/quick-starthttps://vuejs.org/v2/guide/routing.htmlhttps://www.youtube.com/playlist?list=PLu3b11EPo_MfxhGAgO1LTJuDLTMCHIGLvhttps://www.youtube.com/watch?v=4deVCNJq3qc&amp;list=PLkdRA6Qj9ZLLdGArM6bLnnMeH3rH82MEL&amp;index=2&amp;t=0s 基本命令 123456789101112# 提前安装node.js npm# 安装vue.js命令行npm install -g @vue/cli # 创建工程mkdir projectcd projectvue create .# 添加组件vue add vuexvue add vuetifyvue add eslintvue add router","link":"/2019/09/02/Vue.js学习-命令记录/"},{"title":"阿里云iotkit-embedded的坑","text":"硬件配置 STM32F103RCT6 (RAM 64kB, FLASH: 256kB)SIM800C 软件配置 STM32CubeMX 配置 FreeRTOSiotkit-embedded阿里云移植demo iotkit-embedded配置 参考阿里云给出的demo，使用 1make menuconfig 配置 配置时参考阿里云Demo，但要注意： 不要使能PLATFORM_HAS_DYNMEM 频繁从FreeRTOS内部申请内存没有必要，固定内存区域更安全 FreeRTOS调度申请内存有很多种算法，我并不能完全了解 不要使能PLATFORM_HAS_OS 貌似这部分代码在本文写出时还不太完善 SIM800C初始化部分需要改造，频繁申请Mutex和Semaphore 不要使用OTA功能 没有SSL，玩不起来 配置完成后编译时缺个log库，include删除就好 移植 移植wrapper.c 把所有的Mutex和Semaphore相关的函数全部返回正常（看一下头部说明）一定要实现HAL_Snprintf，参考HAL_SleepMS使用osDelay实现Malloc使用pvPortMalloc(), HAL_Free使用vPortFree() 不得不说的是，即使你关闭了PLATFORM_HAS_DYNMEM，iotkit-embedded还是会调用这个函数，我记得出现在上报版本信息这个函数中 HAL_AT_Uart_Send使用HAL_UART_Transmit_IT连续发送，并在发送结束后判断gState，使用osDelay让出时间片HAL_AT_Uart_Recv使用STM32串口文章中所提的方法，用队列接收，并自定义超时注意一下iotx_mqtt_config.h中的IOTX_MC_TX_MAX_LEN以及IOTX_MC_RX_MAX_LEN，数据千万不要超了，或者修改宏定义，不然找都找不到在哪出错CONFIG_MQTT_TOPIC_MAXLEN这个最大的topic长度八成不够长，自己改下就好。最最重要的一个坑： 千万不要把example_publish这个函数中的内容分成几个函数块调用原因是IOT_MQTT_Construct(&amp;mqtt_params)这个函数内会直接使用mqtt_params的字符串，并保存；当你再使用yield以及publish这些函数时，有可能会重新连接，造成野指针程序跑飞。 重启SIM800C 担心SIM800C会挂，以及网络失败，需要hack一下代码 定时以及发现一直连接失败时重启sim800C只需要改造IOT_ATM_Init以及它调用的函数 忽略at_parser_init返回的错误设置reset_sim800c标签，在at_conn_init内重置at_conn_init_done（因为要把atconnects重置）HAL_AT_CONN_Init内重置inited，这样它会重新检测sim800的状态。 总结 暂时只能想起这么多了，如果有遗漏那么抱歉了。。 开源库不是那么好用，想用上，是要付出代价的。 解释 为什么不提PR？ 因为大部分其实不是bug，只是没有相关文档，我们不知道而已。 为什么不放出代码？ 公司代码。","link":"/2019/07/19/阿里云iotkit-embedded的坑/"}],"tags":[{"name":"电力电子","slug":"电力电子","link":"/tags/电力电子/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"前端","slug":"前端","link":"/tags/前端/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"RaspberryPI","slug":"RaspberryPI","link":"/tags/RaspberryPI/"},{"name":"嵌入式","slug":"嵌入式","link":"/tags/嵌入式/"},{"name":"技术","slug":"技术","link":"/tags/技术/"},{"name":"STM32","slug":"STM32","link":"/tags/STM32/"},{"name":"Vue.js","slug":"Vue-js","link":"/tags/Vue-js/"},{"name":"物联网","slug":"物联网","link":"/tags/物联网/"}],"categories":[{"name":"电力电子","slug":"电力电子","link":"/categories/电力电子/"},{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"RaspberryPI","slug":"RaspberryPI","link":"/categories/RaspberryPI/"},{"name":"STM32","slug":"STM32","link":"/categories/STM32/"},{"name":"物联网","slug":"物联网","link":"/categories/物联网/"},{"name":"HAL库","slug":"STM32/HAL库","link":"/categories/STM32/HAL库/"},{"name":"嵌入式上云","slug":"物联网/嵌入式上云","link":"/categories/物联网/嵌入式上云/"}]}